# Generate a minimalistic, absolutely-dedicated dBdt! function
# to hand out to the ODE solver.
# The generated function is only valid for one specific value of `ModelParameters`,
# and must be re-generated any time the parameters change
# and/or the associated network topology.

# The code below works with julia representations of julia code,
# in terms of julia's "symbols" and "expressions".
# The idea is that identifiers within the simple expressions
# explicitly appearing in the program
# will be successively transformed according to replacement rules
# until the whole code in dBdt! is generated.

"""
Construct a copy of the expression with the replacements given in `rep`.

```jldoctest
julia> import BEFWM2: replace

julia> replace(:(a + (b + c / a)), Dict(:a => 5, :b => 8))
:(5 + (8 + c / 5))
```
"""
function replace(xp, rep)
    # Degenerated single occurence case.
    if haskey(rep, xp)
        return rep[xp]
    end
    # Deep-copy with a recursive descent.
    res = Expr(xp.head)
    for a in xp.args
        if haskey(rep, a)
            a = rep[a]
        elseif isa(a, Expr)
            a = replace(a, rep)
        end
        push!(res.args, a)
    end
    res
end

"""
Repeat the given expression into terms of a sum,
successively replacing `indexes` in `term` by elements in (zipped) `lists`.
```jldoctest
julia> import BEFWM2: xp_sum

julia> xp_sum([:i], [[1, 2, 3]], :(u^i)) #  Three terms.
:(u ^ 1 + u ^ 2 + u ^ 3)

julia> xp_sum([:i], [[1]], :(u^i)) #  Single term.
:(u ^ 1)

julia> xp_sum([:i], [[]], :(u^i)) #  No terms.
0

julia> xp_sum([:i, :j], [[:a, :b, :c], [5, 8, 13]], :(j * i)) #  Zipped indices.
:(5a + 8b + 13c)
```
"""
function xp_sum(indexes, lists, term)
    n_terms = min((length(l) for l in lists)...)
    if n_terms == 0
        return 0
    end
    if n_terms == 1
        reps = Dict(index => v for (index, v) in zip(indexes, first(zip(lists...))))
        return replace(term, reps)
    end
    sum = Expr(:call, :+)
    for values in zip(lists...)
        reps = Dict(index => v for (index, v) in zip(indexes, values))
        push!(sum.args, replace(term, reps))
    end
    sum
end

# Recursively visit the expression to modify it once according to the transformation rules.
# The rules are plain symbols corresponding functions identifiers returning expressions.
#  - When appearing as plain identifier like in `1 + symbol + 2`, they are replaced
#    with the expression returned by `symbol(data...)`.
#  - When appearing as function calls like `1 + symbol(expr, expr) + 2`, they are replaced
#    with the expression returned by `symbol(expr, expr)` as one would expect.
# Return false when no modification has been made, so no more expansion step is needed.
function expand!(xp, rules, data)
    modified = false
    for (n, a) in enumerate(xp.args)
        # Simple identifier case.
        if a in rules
            xp.args[n] = eval(a)(data...)
            modified = true
        elseif isa(a, Expr)
            # Call-like identifier(args).
            if a.head == :call && a.args[1] in rules
                xp.args[n] = eval(a)
                modified = true
            else
                modified |= expand!(a, rules, data)
            end
        end
    end
    modified
end

"""
    generate_dbdt(parms::ModelParameters)

Produce a specialized julia expression
supposed to improve resource efficiency of subsequent simulation.
The returned expression is typically
[`eval`](https://docs.julialang.org/en/v1/devdocs/eval/)uated
then passed as a `diff_function` argument to [`simulate`](@ref).
"""
function generate_dbdt(parms::ModelParameters)
    dbdt = :(function (dB, B, _, t)

        # Here are the various lines generated by the code below.

    end)

    # Generate relevant lines.
    function_lines = dbdt.args[2].args
    append!(function_lines, generate_fr_lines(parms))
    append!(function_lines, generate_db_lines(parms))

    dbdt
end

# Functional response lines depend on the functional response type.
# No matrix/array is allocated: only one float variable per nonzero entry.
function generate_fr_lines(parms::ModelParameters)

    # Find nonzero entries in the matrix.
    # This logic mimicks and DUPLICATES the logic in `(F::FunctionalResponse)(B)`.
    F = parms.functional_response
    cons, res = findnz(F.Ï‰)

    lines = []
    for (i, j) in zip(cons, res)
        typical_line = :(
            F_ij = F(B, i, j) #  (<- lhs here is just decorative/illustrative)
        )
        line = replace(typical_line, Dict(:F_ij => Symbol(:F_, i, :_, j)))
        # Generate actual lhs, depending on the functional response type.
        line.args[2] = F(i, j, preys_of(i, parms.network))
        while expand!(line, [:xp_sum], [])
        end
        push!(lines, line)
    end
    lines
end

# Main entry point into the ODE equation lines.
function generate_db_lines(parms::ModelParameters)
    S = richness(parms.network)
    lines = []
    for i in 1:S
        typical_line = :(dB[i] = logisticgrowth + eating - being_eaten - metabolism_loss)
        line = replace(typical_line, Dict(:i => i))
        while expand!(
            line,
            [
                # Comment in and out to check various expansion parts / stages.
                :logisticgrowth,
                :eating,
                :being_eaten,
                :metabolism_loss,
                :xp_sum,
            ],
            [i, parms],
        )
        end
        push!(lines, line)
    end
    lines
end
