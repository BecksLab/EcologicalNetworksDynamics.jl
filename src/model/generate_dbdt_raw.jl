function generate_dbdt_raw(parms::ModelParameters)
    data = nothing
    code = :(function (dB, B, p, t)

        (_, extinct_species) = p

        FR_LINES # Actually generated by the code below.

        DB_LINES # Actually generated by the code below.

        for i in keys(extinct_species)
            B[i] = 0
        end

    end)

    # Extract relevant insertion points in the block.
    lines = code.args[2].args
    ifr, idb = (findall(l -> l == s, lines)[1] for s in (:FR_LINES, :DB_LINES))
    prefix, suffix = lines[1:ifr-2], lines[idb+1:end]

    # Generate relevant lines.
    fr_lines = generate_fr_lines(parms)
    db_lines = generate_db_lines(parms)

    # Reconstruct generated function body.
    code.args[2].args = vcat(prefix, fr_lines, db_lines, suffix)

    return code, data
end

# Functional response lines depend on the functional response type.
# No matrix/array is allocated: only one float variable per nonzero entry.
function generate_fr_lines(parms::ModelParameters)

    # Find nonzero entries in the matrix.
    # This logic mimicks and DUPLICATES the logic in `(F::FunctionalResponse)(B)`.
    F = parms.functional_response
    cons, res = findnz(F.Ï‰)

    # As it turns out now, denominators are typically independent of j,
    # so the corresponding lines can be factorized up to ease compilation time
    # of the generated expression.
    denominators = Set() #  Fill with the ones already generated.
    lines = []
    for (i, j) in zip(cons, res)
        D_i = Symbol(:D_, i)
        F_ij = Symbol(:F_, i, :_, j)
        num, denom = F(i, j, parms.network, :_)
        if denom != 1 #  Sophisticated cases with complex denominators: Classic/Bionergetic.
            if !(i in denominators)
                # Insert this denominator line the first time we need this value.
                denom_line = :(
                    $D_i = $denom #  <- Only inserted once for every j.
                )
                while expand!(denom_line, [:xp_sum], [])
                end
                push!(lines, denom_line)
                push!(denominators, i)
            end
            F_line = :(
                $F_ij = $num / $D_i #  <- Inserted once for every ij.
            )
        else #  Trivial Linear case.
            F_ij = Symbol(:F_, i, :_, j)
            F_line = :(
                $F_ij = $num #  <- Denominator is 1.
            )
        end
        while expand!(F_line, [:xp_sum], [])  #  (for potential future extensions)
        end
        push!(lines, F_line)
    end
    lines
end

# Main entry point into the ODE equation lines.
function generate_db_lines(parms::ModelParameters)
    S = richness(parms.network)
    lines = []
    for i in 1:S
        typical_line = :(
            dB[i] =
                logisticgrowth + eating - being_eaten - metabolism_loss -
                natural_death_loss
        )
        line = replace(typical_line, Dict(:i => i))
        while expand!(
            line,
            [
                # Comment in and out to check various expansion parts / stages.
                :logisticgrowth,
                :eating,
                :being_eaten,
                :metabolism_loss,
                :natural_death_loss,
                :xp_sum,
            ],
            [i, parms],
        )
        end
        push!(lines, line)
    end
    lines
end
