function generate_dbdt_raw(parms::ModelParameters)
    data = nothing
    code = :(function (dB, B, _, t)

        # Here are the various lines generated by the code below.

    end)

    # Edit the lines in the block.
    function_lines = code.args[2].args

    # Generate relevant lines.
    append!(function_lines, generate_fr_lines(parms))
    append!(function_lines, generate_db_lines(parms))

    return code, data
end

# Functional response lines depend on the functional response type.
# No matrix/array is allocated: only one float variable per nonzero entry.
function generate_fr_lines(parms::ModelParameters)

    # Find nonzero entries in the matrix.
    # This logic mimicks and DUPLICATES the logic in `(F::FunctionalResponse)(B)`.
    F = parms.functional_response
    cons, res = findnz(F.Ï‰)

    # As it turns out now, denominators are typically independent of j,
    # so the corresponding lines can be factorized up to ease compilation time
    # of the generated expression.
    denominators = Set() #  Fill with the ones already generated.
    lines = []
    for (i, j) in zip(cons, res)
        D_i = Symbol(:D_, i)
        F_ij = Symbol(:F_, i, :_, j)
        num, denom = F(i, j, preys_of(i, parms.network))
        if denom != 1 #  Sophisticated cases with complex denominators: Classic/Bionergetic.
            if !(i in denominators)
                # Insert this denominator line the first time we need this value.
                denom_line = :(
                    $D_i = $denom #  <- Only inserted once for every j.
                )
                while expand!(denom_line, [:xp_sum], [])
                end
                push!(lines, denom_line)
                push!(denominators, i)
            end
            F_line = :(
                $F_ij = $num / $D_i #  <- Inserted once for every ij.
            )
        else #  Trivial Linear case.
            F_ij = Symbol(:F_, i, :_, j)
            F_line = :(
                $F_ij = $num #  <- Denominator is 1.
            )
        end
        while expand!(F_line, [:xp_sum], [])  #  (for potential future extensions)
        end
        push!(lines, F_line)
    end
    lines
end

# Main entry point into the ODE equation lines.
function generate_db_lines(parms::ModelParameters)
    S = richness(parms.network)
    lines = []
    for i in 1:S
        typical_line = :(dB[i] = logisticgrowth + eating - being_eaten - metabolism_loss)
        line = replace(typical_line, Dict(:i => i))
        while expand!(
            line,
            [
                # Comment in and out to check various expansion parts / stages.
                :logisticgrowth,
                :eating,
                :being_eaten,
                :metabolism_loss,
                :xp_sum,
            ],
            [i, parms],
        )
        end
        push!(lines, line)
    end
    lines
end
