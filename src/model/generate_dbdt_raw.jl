function generate_dbdt_raw(parms::ModelParameters)
    data = nothing
    code = :(function (dB, B, _, t)

        # Here are the various lines generated by the code below.

    end)

    # Edit the lines in the block.
    function_lines = code.args[2].args

    # Generate relevant lines.
    append!(function_lines, generate_fr_lines(parms))
    append!(function_lines, generate_db_lines(parms))

    return code, data
end

# Functional response lines depend on the functional response type.
# No matrix/array is allocated: only one float variable per nonzero entry.
function generate_fr_lines(parms::ModelParameters)

    # Find nonzero entries in the matrix.
    # This logic mimicks and DUPLICATES the logic in `(F::FunctionalResponse)(B)`.
    F = parms.functional_response
    cons, res = findnz(F.Ï‰)

    lines = []
    for (i, j) in zip(cons, res)
        typical_line = :(
            F_ij = F(B, i, j) #  (<- lhs here is just decorative/illustrative)
        )
        line = replace(typical_line, Dict(:F_ij => Symbol(:F_, i, :_, j)))
        # Generate actual lhs, depending on the functional response type.
        line.args[2] = F(i, j, preys_of(i, parms.network))
        while expand!(line, [:xp_sum], [])
        end
        push!(lines, line)
    end
    lines
end

# Main entry point into the ODE equation lines.
function generate_db_lines(parms::ModelParameters)
    S = richness(parms.network)
    lines = []
    for i in 1:S
        typical_line = :(dB[i] = logisticgrowth + eating - being_eaten - metabolism_loss)
        line = replace(typical_line, Dict(:i => i))
        while expand!(
            line,
            [
                # Comment in and out to check various expansion parts / stages.
                :logisticgrowth,
                :eating,
                :being_eaten,
                :metabolism_loss,
                :xp_sum,
            ],
            [i, parms],
        )
        end
        push!(lines, line)
    end
    lines
end
